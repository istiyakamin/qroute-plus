<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Q-Route+ Visualizer (Standalone)</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React & ReactDOM UMD -->
  <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <!-- Babel for in-browser JSX transform (not for production) -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Chart.js for visualizations -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>html,body,#root{height:100%;margin:0} body{background:#f8fafc}</style>
</head>
<body>
  <div id="root" class="h-full"></div>

  <script type="text/babel">
  // Adapted from q_route_visualizer_java_script_react_tailwind.jsx
  const { useMemo, useRef, useState, useEffect } = React;

  const CANVAS_W = 1000;
  const CANVAS_H = 700;
  const SCALE_KM = 0.06; // each canvas unit ~0.06 km (tweak to get reasonable minutes)

  // ---------- Utilities ----------
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function dist(a, b) {
    const dx = a.x - b.x; const dy = a.y - b.y; return Math.hypot(dx, dy);
  }
  function minutesForDistance(d, speedKmh) {
    const km = d * SCALE_KM; return (km / Math.max(1e-6, speedKmh)) * 60.0;
  }

  function normalSample(mu, sigma) {
    // Box-Muller
    let u = 0, v = 0;
    while (u === 0) u = Math.random();
    while (v === 0) v = Math.random();
    const z = Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v);
    return Math.max(0, mu + sigma * z);
  }

  function zQuantile(eps) {
    // return z_{1-eps}
    const table = [
      [0.20, 0.84162], [0.15, 1.03643], [0.10, 1.28155], [0.07, 1.47579],
      [0.05, 1.64485], [0.025, 1.95996], [0.02, 2.05375], [0.01, 2.32635], [0.005, 2.57583]
    ];
    let best = table[0][1], bestErr = Infinity;
    for (const [e, z] of table) {
      const err = Math.abs(e - eps);
      if (err < bestErr) { best = z; bestErr = err; }
    }
    return best;
  }

  // ---------- Data generation ----------
  function genSites(n, withTW=true) {
    const sites = [];
    for (let i = 0; i < n; i++) {
      const x = randBetween(60, CANVAS_W - 60);
      const y = randBetween(60, CANVAS_H - 60);
      const mu = randBetween(50, 150); // liters
      const sigma = randBetween(0.15, 0.4) * mu; // 15-40% CV
      const service = randBetween(4, 10); // minutes
      let e = 0, l = 480; // default window: all day
      if (withTW) {
        const start = Math.floor(randBetween(0, 240));
        const len = Math.floor(randBetween(150, 300));
        e = start; l = clamp(start + len, start + 60, 480);
      }
      sites.push({ id: i + 1, x, y, mu, sigma, e, l, service, selected: true });
    }
    return sites;
  }

  function genVehicles(k, capacity=300, shift=[0,480]) {
    return Array.from({length:k}, (_,i)=>({ id:i, capacity, start: shift[0], end: shift[1] }));
  }

  // ---------- QRO bounds ----------
  function bernsteinBound(muSum, varSum, eps, b) {
    // returns threshold = mu + sqrt(2*var*ln(1/eps)) + (2/3) b ln(1/eps)
    const L = Math.log(1/Math.max(1e-9, eps));
    return muSum + Math.sqrt(2 * Math.max(0, varSum) * L) + (2/3) * b * L;
  }

  function normalQuantileBound(muSum, varSum, eps) {
    const z = zQuantile(eps);
    return muSum + z * Math.sqrt(Math.max(0, varSum));
  }

  // ---------- Routing structures ----------
  function makeDepot() { return { id: 0, x: CANVAS_W/2, y: CANVAS_H/2, mu:0, sigma:0, e:0, l:480, service:0 } }

  class Route {
    constructor(vehicle) {
      this.vehicle = vehicle;
      this.nodes = [0, 0]; // depot indices
      this.arrival = [vehicle.start, vehicle.start];
      this.muSum = 0; this.varSum = 0; // variance includes correlation handled outside if used
      this.members = new Set();
    }
  }

  // ---------- Correlation helper ----------
  // For demo: use a global rho in [0,1) applied pairwise: Cov(i,j) = rho * sigma_i * sigma_j
  function updateVarSumWithRho(route, site, sitesById, rho) {
    let cross = 0;
    for (const sid of route.members) {
      const s = sitesById.get(sid);
      cross += rho * s.sigma * site.sigma;
    }
    return route.varSum + site.sigma*site.sigma + 2*cross;
  }

  // ---------- Time feasibility re-compute forward ----------
  function timeFeasibleAfterInsert(inst, route, siteIdx, pos) {
    const { sitesByIdx, speedKmh } = inst;
    const nodes = route.nodes.slice();
    const arr = route.arrival.slice();
    nodes.splice(pos, 0, siteIdx);
    arr.splice(pos, 0, null);

    const veh = route.vehicle;
    const getSite = idx => idx===0? makeDepot() : sitesByIdx.get(idx);

    for (let k = 1; k < nodes.length; k++) {
      const prev = nodes[k-1], cur = nodes[k];
      const prevSite = getSite(prev);
      const curSite = getSite(cur);
      const travelMin = minutesForDistance(dist(prevSite, curSite), speedKmh);
      const tentative = (arr[k-1] ?? veh.start) + (prev===0?0:prevSite.service) + travelMin;
      if (cur === 0) { arr[k] = tentative; }
      else {
        const a = Math.max(tentative, curSite.e);
        if (a > curSite.l + 1e-6) return false;
        arr[k] = a;
      }
    }
    if (arr[arr.length-1] > veh.end + 1e-6) return false;
    return true;
  }

  function applyInsert(inst, route, siteIdx, pos) {
    const { sitesByIdx, rho, boundType, eps, bParam } = inst;
    const site = sitesByIdx.get(siteIdx);
    route.nodes.splice(pos, 0, siteIdx);
    // recompute arrival forward
    const veh = route.vehicle;
    const getSite = idx => idx===0? makeDepot() : sitesByIdx.get(idx);
    route.arrival.splice(pos, 0, 0);
    for (let k=1; k<route.nodes.length; k++){
      const prev = route.nodes[k-1], cur = route.nodes[k];
      const sPrev = getSite(prev), sCur = getSite(cur);
      const travelMin = minutesForDistance(dist(sPrev, sCur), inst.speedKmh);
      const tentative = route.arrival[k-1] + (prev===0?0:sPrev.service) + travelMin;
      route.arrival[k] = (cur===0) ? tentative : Math.max(tentative, sCur.e);
    }
    // update moments
    const newVar = updateVarSumWithRho(route, site, sitesByIdx, rho);
    route.muSum += site.mu;
    route.varSum = newVar;
    route.members.add(siteIdx);
  }

  function qroFeasible(inst, route, siteIdx, pos) {
    const { sitesByIdx, eps, rho, boundType, bParam } = inst;
    const vehCap = route.vehicle.capacity;
    const site = sitesByIdx.get(siteIdx);
    // capacity bound (provisional) with updated variance including correlation
    const varNew = updateVarSumWithRho(route, site, sitesByIdx, rho);
    const muNew = route.muSum + site.mu;
    const thr = (boundType === "bernstein")
      ? bernsteinBound(muNew, varNew, eps, bParam)
      : normalQuantileBound(muNew, varNew, eps);
    if (thr > vehCap + 1e-9) return false;
    // time windows
    return timeFeasibleAfterInsert(inst, route, siteIdx, pos);
  }

  // ---------- Greedy QRO construction ----------
  function buildRoutesQRO(inst, visitMask) {
    const routes = inst.vehicles.map(v => new Route(v));
    const sites = inst.sites;
    const toVisit = sites.filter((s,idx)=>visitMask[idx]).map(s=>s.id);
    const skipped = sites.filter((s,idx)=>!visitMask[idx]).map(s=>s.id);

    // heuristic: order by sigma desc, then mu desc
    toVisit.sort((a,b)=>{
      const sa = inst.sitesByIdx.get(a), sb = inst.sitesByIdx.get(b);
      return (sb.sigma - sa.sigma) || (sb.mu - sa.mu);
    });

    for (const sid of toVisit) {
      let best = null; // {delta, rIndex, pos}
      for (let rIndex=0; rIndex<routes.length; rIndex++){
        const r = routes[rIndex];
        for (let pos=1; pos<r.nodes.length; pos++){
          if (!qroFeasible(inst, r, sid, pos)) continue;
          const prev = r.nodes[pos-1], cur = r.nodes[pos];
          const sPrev = prev===0? makeDepot():inst.sitesByIdx.get(prev);
          const sCur  = cur===0? makeDepot():inst.sitesByIdx.get(cur);
          const sNew  = inst.sitesByIdx.get(sid);
          const d0 = dist(sPrev, sCur);
          const d1 = dist(sPrev, sNew) + dist(sNew, sCur);
          const delta = d1 - d0;
          if (!best || delta < best.delta) best = { delta, rIndex, pos };
        }
      }
      if (best) {
        applyInsert(inst, routes[best.rIndex], sid, best.pos);
      } else {
        // try put on empty route at pos 1
        let placed = false;
        for (let rIndex=0; rIndex<routes.length; rIndex++){
          const r = routes[rIndex];
          if (r.nodes.length===2 && qroFeasible(inst, r, sid, 1)) {
            applyInsert(inst, r, sid, 1); placed = true; break;
          }
        }
        if (!placed) skipped.push(sid);
      }
    }
    return { routes, skipped };
  }

  // ---------- 2-opt local improvement (distance only, keep QRO feasibility) ----------
  function twoOptImprove(inst, route, attempts=200) {
    const getSite = idx => idx===0? makeDepot() : inst.sitesByIdx.get(idx);
    const nodes = route.nodes.slice();
    const n = nodes.length;
    if (n < 5) return; // nothing to do

    for (let it=0; it<attempts; it++){
      const i = Math.floor(randBetween(1, n-3));
      const j = Math.floor(randBetween(i+1, n-2));
      const cand = nodes.slice(0,i).concat(nodes.slice(i,j+1).reverse(), nodes.slice(j+1));
      // quick time + QRO check by reconstructing moments
      let arr = [route.vehicle.start];
      let mu = 0, varSum = 0; let ok = true; let members = new Set();
      for (let k=1; k<cand.length; k++){
        const prev = cand[k-1], cur = cand[k];
        const sp = getSite(prev), sc = getSite(cur);
        const travel = minutesForDistance(dist(sp, sc), inst.speedKmh);
        const tentative = arr[k-1] + (prev===0?0:sp.service) + travel;
        const a = (cur===0) ? tentative : Math.max(tentative, sc.e);
        if (cur!==0 && a>sc.l+1e-6) { ok=false; break; }
        arr[k] = a;
        if (cur!==0){
          // update var with rho correlation
          let cross = 0; members.forEach(sid=>{ const s = inst.sitesByIdx.get(sid); cross += inst.rho * s.sigma * sc.sigma; });
          varSum = varSum + sc.sigma*sc.sigma + 2*cross;
          mu += sc.mu; members.add(cur);
        }
      }
      if (!ok) continue;
      const thr = (inst.boundType==="bernstein")
        ? bernsteinBound(mu, varSum, inst.eps, inst.bParam)
        : normalQuantileBound(mu, varSum, inst.eps);
      if (thr > route.vehicle.capacity + 1e-9) continue;

      // compute distances
      const oldLen = polylineLength(nodes.map(getSite));
      const newLen = polylineLength(cand.map(getSite));
      if (newLen + 1e-6 < oldLen) {
        // accept
        route.nodes = cand;
        route.arrival = arr;
        route.muSum = mu; route.varSum = varSum; route.members = members;
      }
    }
  }

  function polylineLength(points){
    let L=0; for (let i=0;i<points.length-1;i++) L += dist(points[i], points[i+1]); return L;
  }

  // ---------- Monte Carlo overflow ----------
  function simulateOverflow(inst, routes, trials=300) {
    let over = 0, total = 0;
    for (let t=0; t<trials; t++){
      for (const r of routes){
        let vol = 0;
        for (const idx of r.nodes) {
          if (idx===0) continue;
          const s = inst.sitesByIdx.get(idx);
          vol += normalSample(s.mu, s.sigma);
        }
        total++;
        if (vol > r.vehicle.capacity + 1e-9) over++;
      }
    }
    return over / Math.max(1, total);
  }

  // Detailed Monte Carlo: per-route realized overflow and predicted risk ratio
  function simulateOverflowDetails(inst, routes, trials=300){
    const details = [];
    let overAll = 0, totalAll = 0;
    for (const r of routes){
      // predicted bound ratio
      const thr = (inst.boundType === "bernstein")
        ? bernsteinBound(r.muSum, r.varSum, inst.eps, inst.bParam)
        : normalQuantileBound(r.muSum, r.varSum, inst.eps);
      const predictedRatio = thr / r.vehicle.capacity;

      let over=0;
      for (let t=0;t<trials;t++){
        let vol=0;
        for (const idx of r.nodes){
          if (idx===0) continue;
          const s = inst.sitesByIdx.get(idx);
          vol += normalSample(s.mu, s.sigma);
        }
        if (vol > r.vehicle.capacity + 1e-9) over++;
      }
      const rate = over / Math.max(1, trials);
      details.push({ vehicleId: r.vehicle.id, predictedRatio, capacity: r.vehicle.capacity, rate });
      overAll += over; totalAll += trials;
    }
    return { overall: overAll/Math.max(1,totalAll), details };
  }

  // ---------- React App ----------
  function App(){
    const [seed, setSeed] = useState(42);
    const [nSites, setNSites] = useState(60);
    const [nVeh, setNVeh] = useState(3);
    const [capacity, setCapacity] = useState(300);
    const [speedKmh, setSpeedKmh] = useState(30);
    const [epsilon, setEpsilon] = useState(0.05);
    const [emissionPerKm, setEmissionPerKm] = useState(0.9);
    const [useTW, setUseTW] = useState(true);
    const [rho, setRho] = useState(0.0);
    const [boundType, setBoundType] = useState("bernstein");
    const [bParam, setBParam] = useState(40); // liters radius for Bernstein
    const [sites, setSites] = useState(()=>genSites(nSites, useTW));
    const [vehicles, setVehicles] = useState(()=>genVehicles(nVeh, capacity));
    const [visitMask, setVisitMask] = useState(()=>Array(nSites).fill(true));

    // Build instance object
    const inst = useMemo(()=>{
      const depot = makeDepot();
      const sitesByIdx = new Map();
      sites.forEach(s=>sitesByIdx.set(s.id, s));
      return {
        depot, sites, sitesByIdx, vehicles,
        eps: epsilon, speedKmh, rho, bParam,
        boundType, emissionPerKm
      };
    }, [sites, vehicles, epsilon, speedKmh, rho, boundType, bParam, emissionPerKm]);

    const [solution, setSolution] = useState(null);
  const [simOverflow, setSimOverflow] = useState(null);
  const [simDetails, setSimDetails] = useState(null);
  const [showCharts, setShowCharts] = useState(false);
  const [chartRouteIndex, setChartRouteIndex] = useState(0);
    const [running, setRunning] = useState(false);
    const [showDataModal, setShowDataModal] = useState(false);

    function reseed(){
      const newSeed = Math.floor(Math.random()*1e6);
      setSeed(newSeed);
    }

    function regenerate(){
      const s = genSites(nSites, useTW);
      const v = genVehicles(nVeh, capacity);
      setSites(s); setVehicles(v); setVisitMask(Array(nSites).fill(true));
      setSolution(null); setSimOverflow(null);
    }

    function runBuild(twoOpt=false){
      setRunning(true);
      requestAnimationFrame(()=>{
        const { routes, skipped } = buildRoutesQRO(inst, visitMask);
        if (twoOpt) routes.forEach(r=>twoOptImprove(inst, r, 200));
        const km = routes.reduce((acc,r)=>acc+polylineLength(r.nodes.map(idx=>idx===0?inst.depot:inst.sitesByIdx.get(idx))),0) * SCALE_KM;
        const minutes = routes.reduce((acc,r)=>acc + (r.arrival[r.arrival.length-1] - r.vehicle.start), 0);
        const co2 = km * inst.emissionPerKm;
        
        // Enhanced KPIs
        const totalSites = inst.sites.length;
        const visitedSites = totalSites - skipped.length;
        const utilizationRate = visitedSites / totalSites;
        const avgRouteLength = km / routes.filter(r => r.nodes.length > 2).length || 0;
        const activeVehicles = routes.filter(r => r.nodes.length > 2).length;
        const vehicleUtilization = activeVehicles / routes.length;
        
        // Capacity utilization
        const totalCapacityUsed = routes.reduce((acc, r) => acc + r.muSum, 0);
        const totalCapacityAvailable = routes.reduce((acc, r) => acc + r.vehicle.capacity, 0);
        const capacityUtilization = totalCapacityUsed / totalCapacityAvailable;
        
        // Risk metrics
        const avgRiskPerRoute = routes.map(r => {
          const thr = (inst.boundType === "bernstein")
            ? bernsteinBound(r.muSum, r.varSum, inst.eps, inst.bParam)
            : normalQuantileBound(r.muSum, r.varSum, inst.eps);
          return thr / r.vehicle.capacity;
        });
        const maxRiskRatio = Math.max(...avgRiskPerRoute, 0);
        const avgRiskRatio = avgRiskPerRoute.reduce((a,b) => a + b, 0) / Math.max(1, avgRiskPerRoute.length);
        
        // Time window compliance
        const twViolations = routes.reduce((acc, r) => {
          let violations = 0;
          for (let i = 1; i < r.nodes.length - 1; i++) {
            const site = inst.sitesByIdx.get(r.nodes[i]);
            if (r.arrival[i] > site.l + 1e-6) violations++;
          }
          return acc + violations;
        }, 0);
        
        // Economic metrics (example costs)
        const fuelCostPerKm = 1.5; // €/km
        const driverCostPerHour = 25; // €/hour
        const vehicleFixedCost = 50; // €/vehicle/day
        
        const fuelCost = km * fuelCostPerKm;
        const driverCost = (minutes / 60) * driverCostPerHour;
        const vehicleCost = activeVehicles * vehicleFixedCost;
        const totalOperationalCost = fuelCost + driverCost + vehicleCost;
        
        // Service quality
        const avgServiceTime = routes.reduce((acc, r) => {
          let serviceTime = 0;
          for (let i = 1; i < r.nodes.length - 1; i++) {
            const site = inst.sitesByIdx.get(r.nodes[i]);
            serviceTime += site.service;
          }
          return acc + serviceTime;
        }, 0);
        
        const longestRoute = Math.max(...routes.map(r => 
          r.arrival[r.arrival.length-1] - r.vehicle.start), 0);
        const shortestRoute = Math.min(...routes.filter(r => r.nodes.length > 2)
          .map(r => r.arrival[r.arrival.length-1] - r.vehicle.start), Infinity);
        const routeBalance = shortestRoute === Infinity ? 0 : shortestRoute / longestRoute;

        setSolution({ 
          routes, skipped, km, minutes, co2,
          // Enhanced metrics
          totalSites, visitedSites, utilizationRate, avgRouteLength, activeVehicles,
          vehicleUtilization, capacityUtilization, maxRiskRatio, avgRiskRatio,
          twViolations, fuelCost, driverCost, vehicleCost, totalOperationalCost,
          avgServiceTime, longestRoute, shortestRoute, routeBalance
        });
        setRunning(false);
      });
    }

    function runSim(){
      if (!solution) return;
      const out = simulateOverflowDetails(inst, solution.routes, 500);
      setSimOverflow(out.overall);
      setSimDetails(out);
      setShowCharts(true);
    }

    // Step-through greedy insertion (demo): one site per click
    const [stepState, setStepState] = useState(null);
    
    function startStep(){
      const routes = inst.vehicles.map(v=>new Route(v));
      const toVisit = inst.sites.map(s=>s.id);
      toVisit.sort((a,b)=>{
        const sa = inst.sitesByIdx.get(a), sb = inst.sitesByIdx.get(b);
        return (sb.sigma - sa.sigma) || (sb.mu - sa.mu);
      });
      setStepState({ routes, queue: toVisit, current: null, placed: null });
      setSolution(null); setSimOverflow(null);
    }
    function stepOnce(){
      if (!stepState) return;
      const { routes } = stepState;
      const q = stepState.queue.slice();
      const sid = q.shift();
      if (sid==null){ return; }
      let best=null;
      for (let rIndex=0; rIndex<routes.length; rIndex++){
        const r = routes[rIndex];
        for (let pos=1; pos<r.nodes.length; pos++){
          if (!qroFeasible(inst, r, sid, pos)) continue;
          const prev = r.nodes[pos-1], cur = r.nodes[pos];
          const sPrev = prev===0? makeDepot():inst.sitesByIdx.get(prev);
          const sCur  = cur===0? makeDepot():inst.sitesByIdx.get(cur);
          const sNew  = inst.sitesByIdx.get(sid);
          const d0 = dist(sPrev, sCur);
          const d1 = dist(sPrev, sNew) + dist(sNew, sCur);
          const delta = d1 - d0;
          if (!best || delta < best.delta) best = { rIndex, pos, delta };
        }
      }
      if (best) {
        applyInsert(inst, routes[best.rIndex], sid, best.pos);
        setStepState({ routes, queue: q, current: sid, placed: best });
      } else {
        // skip if not placeable
        setStepState({ routes, queue: q, current: sid, placed: null });
      }
    }

    // ---------- Rendering ----------
    return (
      <div className="w-full h-full grid grid-cols-12 gap-3 p-4 bg-slate-50 text-slate-800">
        {/* Sidebar */}
        <div className="col-span-4 space-y-4">
          <h1 className="text-2xl font-bold">Q‑Route+ Visualizer</h1>
          <p className="text-sm text-slate-600">Interactive demo of risk‑aware routing with the Quantile Route Oracle, predictive skips, and bandit‑guided search (simplified).</p>

          <div className="grid grid-cols-2 gap-2 bg-white p-3 rounded-xl shadow">
            <label className="text-sm">Sites
              <input type="number" min={5} max={500} value={nSites} onChange={e=>setNSites(+e.target.value)} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <label className="text-sm">Vehicles
              <input type="number" min={1} max={10} value={nVeh} onChange={e=>setNVeh(+e.target.value)} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <label className="text-sm">Capacity (L)
              <input type="number" min={50} max={2000} value={capacity} onChange={e=>{setCapacity(+e.target.value); setVehicles(genVehicles(nVeh, +e.target.value));}} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <label className="text-sm">Speed (km/h)
              <input type="number" min={5} max={80} value={speedKmh} onChange={e=>setSpeedKmh(+e.target.value)} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <label className="text-sm">Risk ε
              <input type="number" step={0.005} min={0.005} max={0.2} value={epsilon} onChange={e=>setEpsilon(+e.target.value)} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <label className="text-sm">Emission (kg/km)
              <input type="number" step={0.05} min={0} max={5} value={emissionPerKm} onChange={e=>setEmissionPerKm(+e.target.value)} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <label className="text-sm">Correlation ρ
              <input type="range" min={0} max={0.9} step={0.05} value={rho} onChange={e=>setRho(+e.target.value)} className="w-full"/>
              <div className="text-xs text-slate-500">{rho.toFixed(2)}</div>
            </label>
            <label className="text-sm">Bernstein radius b
              <input type="number" min={0} max={200} value={bParam} onChange={e=>setBParam(+e.target.value)} className="w-full mt-1 px-2 py-1 border rounded"/>
            </label>
            <div className="col-span-2 flex items-center gap-3">
              <label className="text-sm flex items-center gap-2">
                <input type="checkbox" checked={useTW} onChange={e=>{setUseTW(e.target.checked); setSites(genSites(nSites, e.target.checked));}}/>
                Use Time Windows
              </label>
              <label className="text-sm flex items-center gap-2">
                <input type="radio" name="bound" checked={boundType==="bernstein"} onChange={()=>setBoundType("bernstein")}/>
                Bernstein
              </label>
              <label className="text-sm flex items-center gap-2">
                <input type="radio" name="bound" checked={boundType==="normal"} onChange={()=>setBoundType("normal")}/>
                Normal Quantile
              </label>
            </div>
            <div className="col-span-2 flex gap-2">
              <button onClick={regenerate} className="px-3 py-2 bg-slate-900 text-white rounded-lg hover:bg-slate-800">Generate</button>
              <button onClick={()=>runBuild(false)} className="px-3 py-2 bg-emerald-600 text-white rounded-lg hover:bg-emerald-500 disabled:opacity-50" disabled={running}>Run (Greedy)</button>
              <button onClick={()=>runBuild(true)} className="px-3 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-500 disabled:opacity-50" disabled={running}>Run + 2‑opt</button>
            </div>
            <div className="col-span-2 flex gap-2">
              <button onClick={startStep} className="px-3 py-2 bg-sky-600 text-white rounded-lg hover:bg-sky-500">Start Step</button>
              <button onClick={stepOnce} className="px-3 py-2 bg-sky-500 text-white rounded-lg hover:bg-sky-400">Step Once</button>
              <button onClick={runSim} className="px-3 py-2 bg-amber-600 text-white rounded-lg hover:bg-amber-500 disabled:opacity-50" disabled={!solution}>Simulate Overflow</button>
            </div>
            <div className="col-span-2 flex gap-2">
              <button onClick={()=>setShowDataModal(true)} className="px-3 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-500">SHOW DATA</button>
            </div>
          </div>

          {/* KPIs */}
          <div className="bg-white p-3 rounded-xl shadow space-y-2">
            <h2 className="font-semibold">KPIs</h2>
            {solution ? (
              <div className="space-y-3">
                {/* Basic Metrics */}
                <div className="grid grid-cols-2 gap-2 text-sm">
                  <div className="p-2 bg-slate-100 rounded">Distance: <b>{solution.km.toFixed(2)}</b> km</div>
                  <div className="p-2 bg-slate-100 rounded">Drive Time: <b>{solution.minutes.toFixed(0)}</b> min</div>
                  <div className="p-2 bg-slate-100 rounded">CO₂: <b>{solution.co2.toFixed(2)}</b> kg</div>
                  <div className="p-2 bg-slate-100 rounded">Skipped: <b>{solution.skipped.length}</b></div>
                </div>

                {/* Operational Metrics */}
                <div>
                  <h3 className="font-medium text-sm mb-1">Operational Efficiency</h3>
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    <div className="p-2 bg-blue-50 rounded">Site Coverage: <b>{(solution.utilizationRate*100).toFixed(1)}%</b></div>
                    <div className="p-2 bg-blue-50 rounded">Vehicle Usage: <b>{(solution.vehicleUtilization*100).toFixed(1)}%</b></div>
                    <div className="p-2 bg-blue-50 rounded">Capacity Usage: <b>{(solution.capacityUtilization*100).toFixed(1)}%</b></div>
                    <div className="p-2 bg-blue-50 rounded">Route Balance: <b>{(solution.routeBalance*100).toFixed(1)}%</b></div>
                    <div className="p-2 bg-blue-50 rounded">Active Vehicles: <b>{solution.activeVehicles}</b>/{vehicles.length}</div>
                    <div className="p-2 bg-blue-50 rounded">Avg Route: <b>{solution.avgRouteLength.toFixed(1)}</b> km</div>
                  </div>
                </div>

                {/* Risk Metrics */}
                <div>
                  <h3 className="font-medium text-sm mb-1">Risk Assessment</h3>
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    <div className="p-2 bg-orange-50 rounded">Max Risk Ratio: <b>{(solution.maxRiskRatio*100).toFixed(1)}%</b></div>
                    <div className="p-2 bg-orange-50 rounded">Avg Risk Ratio: <b>{(solution.avgRiskRatio*100).toFixed(1)}%</b></div>
                    <div className="p-2 bg-orange-50 rounded">TW Violations: <b>{solution.twViolations}</b></div>
                    <div className="p-2 bg-orange-50 rounded">Target Risk: <b>{(epsilon*100).toFixed(1)}%</b></div>
                  </div>
                </div>

                {/* Economic Metrics */}
                <div>
                  <h3 className="font-medium text-sm mb-1">Cost Analysis (€)</h3>
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    <div className="p-2 bg-green-50 rounded">Fuel Cost: <b>{solution.fuelCost.toFixed(2)}</b></div>
                    <div className="p-2 bg-green-50 rounded">Driver Cost: <b>{solution.driverCost.toFixed(2)}</b></div>
                    <div className="p-2 bg-green-50 rounded">Vehicle Cost: <b>{solution.vehicleCost.toFixed(2)}</b></div>
                    <div className="p-2 bg-green-50 rounded font-medium">Total Cost: <b>{solution.totalOperationalCost.toFixed(2)}</b></div>
                  </div>
                </div>

                {/* Time Metrics */}
                <div>
                  <h3 className="font-medium text-sm mb-1">Time Analysis</h3>
                  <div className="grid grid-cols-2 gap-2 text-xs">
                    <div className="p-2 bg-purple-50 rounded">Service Time: <b>{solution.avgServiceTime.toFixed(0)}</b> min</div>
                    <div className="p-2 bg-purple-50 rounded">Longest Route: <b>{solution.longestRoute.toFixed(0)}</b> min</div>
                    <div className="p-2 bg-purple-50 rounded">Shortest Route: <b>{solution.shortestRoute === Infinity ? 'N/A' : solution.shortestRoute.toFixed(0)}</b> min</div>
                    <div className="p-2 bg-purple-50 rounded">Makespan: <b>{solution.longestRoute.toFixed(0)}</b> min</div>
                  </div>
                </div>

                {/* Simulation Results */}
                {simOverflow != null && (
                  <div className="p-2 bg-amber-50 border border-amber-200 rounded text-sm">
                    <strong>Monte Carlo Simulation:</strong><br/>
                    Overflow rate: <b>{(simOverflow*100).toFixed(1)}%</b> (target ≤ {(epsilon*100).toFixed(1)}%)<br/>
                    <span className={simOverflow <= epsilon ? "text-green-600" : "text-red-600"}>
                      {simOverflow <= epsilon ? "✓ Within target risk" : "⚠ Exceeds target risk"}
                    </span>
                    {simDetails && (
                      <div className="mt-2 text-xs">
                        Per-route: {simDetails.details.map((d,i)=>`v${d.vehicleId}: ${(d.rate*100).toFixed(1)}%`).join(' | ')}
                        <div className="mt-2">
                          <button onClick={()=>setShowCharts(true)} className="px-2 py-1 bg-amber-600 text-white rounded hover:bg-amber-500">Open Charts</button>
                        </div>
                      </div>
                    )}
                  </div>
                )}
              </div>
            ) : (
              <div className="text-sm text-slate-500">Run the algorithm to see metrics.</div>
            )}
          </div>

          {/* Help */}
          <div className="bg-white p-3 rounded-xl shadow text-sm leading-relaxed">
            <h3 className="font-semibold mb-1">How to use</h3>
            <ol className="list-decimal ml-5 space-y-1">
              <li>Choose <b>Sites</b>, <b>Vehicles</b>, capacity, speed, and risk <b>ε</b>.</li>
              <li>Click <b>Generate</b> to create a fresh instance.</li>
              <li>Click <b>Run</b> (or <b>Run + 2‑opt</b>) to build QRO‑feasible routes.</li>
              <li>Optionally <b>Simulate Overflow</b> to estimate realized risk.</li>
              <li>Use <b>Start Step</b> + <b>Step Once</b> to watch greedy insertions.</li>
            </ol>
            <p className="mt-2">Toggle the bound: <i>Bernstein</i> is conservative; <i>Normal</i> is faster and less conservative. Increase <b>ρ</b> to add correlation between sites (harder problem).</p>
          </div>
        </div>

        {/* Canvas */}
        <div className="col-span-8 bg-white rounded-xl shadow relative">
          <CanvasView inst={inst} solution={solution} stepState={stepState} />
        </div>

  {/* Data Modal */}
        {showDataModal && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={()=>setShowDataModal(false)}>
            <div className="bg-white rounded-xl p-6 max-w-4xl max-h-[80vh] overflow-auto" onClick={e=>e.stopPropagation()}>
              <div className="flex justify-between items-center mb-4">
                <h2 className="text-xl font-bold">Generated Site Data</h2>
                <button onClick={()=>setShowDataModal(false)} className="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
              </div>
              <div className="overflow-x-auto">
                <table className="w-full text-sm border-collapse border border-gray-300">
                  <thead>
                    <tr className="bg-gray-100">
                      <th className="border border-gray-300 px-3 py-2 text-left">Site ID</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">X</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">Y</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">Demand μ (L)</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">Demand σ (L)</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">CV (%)</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">Service (min)</th>
                      <th className="border border-gray-300 px-3 py-2 text-left">Time Window</th>
                    </tr>
                  </thead>
                  <tbody>
                    {sites.map(site => (
                      <tr key={site.id} className="hover:bg-gray-50">
                        <td className="border border-gray-300 px-3 py-2">{site.id}</td>
                        <td className="border border-gray-300 px-3 py-2">{site.x.toFixed(0)}</td>
                        <td className="border border-gray-300 px-3 py-2">{site.y.toFixed(0)}</td>
                        <td className="border border-gray-300 px-3 py-2">{site.mu.toFixed(1)}</td>
                        <td className="border border-gray-300 px-3 py-2">{site.sigma.toFixed(1)}</td>
                        <td className="border border-gray-300 px-3 py-2">{((site.sigma/site.mu)*100).toFixed(1)}</td>
                        <td className="border border-gray-300 px-3 py-2">{site.service.toFixed(1)}</td>
                        <td className="border border-gray-300 px-3 py-2">
                          {useTW ? `[${site.e.toFixed(0)}, ${site.l.toFixed(0)}]` : 'All day'}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="mt-4 text-sm text-gray-600">
                <p><strong>Total Sites:</strong> {sites.length}</p>
                <p><strong>Total Demand μ:</strong> {sites.reduce((sum, s) => sum + s.mu, 0).toFixed(1)} L</p>
                <p><strong>Average CV:</strong> {(sites.reduce((sum, s) => sum + (s.sigma/s.mu), 0) / sites.length * 100).toFixed(1)}%</p>
              </div>
            </div>
          </div>
        )}

        {/* Charts Modal */}
        {showCharts && simDetails && (
          <ChartsModal simDetails={simDetails} solution={solution} inst={inst} onClose={()=>setShowCharts(false)} />
        )}
      </div>
    );
  }

  function ChartsModal({ simDetails, solution, inst, onClose }){
    const scatterRef = React.useRef(null);
    const histRef = React.useRef(null);
    const [routeIdx, setRouteIdx] = React.useState(0);
    const [scatterChart, setScatterChart] = React.useState(null);
    const [histChart, setHistChart] = React.useState(null);

    // helper to sample volumes for a route
    function sampleVolumesForRoute(route, trials=600){
      const vols = [];
      for (let t=0;t<trials;t++){
        let vol=0; for (const idx of route.nodes){ if (idx===0) continue; const s=inst.sitesByIdx.get(idx); vol += normalSample(s.mu, s.sigma);} vols.push(vol);
      }
      return vols;
    }

    function makeHistogram(data, bins=20){
      const min = Math.min(...data), max = Math.max(...data);
      const width = (max-min)/Math.max(1,bins);
      const edges = Array.from({length:bins+1}, (_,i)=>min + i*width);
      const counts = new Array(bins).fill(0);
      for (const x of data){
        let b = Math.floor((x-min)/Math.max(1e-9,width)); b = Math.min(bins-1, Math.max(0,b)); counts[b]++;
      }
      const labels = counts.map((_,i)=>((edges[i]+edges[i+1])/2).toFixed(0));
      return { labels, counts };
    }

    React.useEffect(()=>{
      // build scatter: predicted ratio vs realized overflow
      const ctx = scatterRef.current.getContext('2d');
      if (scatterChart) { scatterChart.destroy(); }
      const data = simDetails.details.map((d,i)=>({ x: d.predictedRatio, y: d.rate, r: 5, label: `v${d.vehicleId}` }));
      const sc = new Chart(ctx, {
        type: 'scatter',
        data: { datasets: [{ label: 'Calibration', data, backgroundColor: '#2563eb' }] },
        options: {
          responsive: true,
          scales: {
            x: { title: { display: true, text: 'Predicted ratio (threshold / capacity)' }, min: 0, max: Math.max(1.2, ...data.map(p=>p.x)) },
            y: { title: { display: true, text: 'Realized overflow rate' }, min: 0, max: Math.min(1, Math.max(0.2, ...data.map(p=>p.y))*1.1) }
          },
          plugins: { legend: { display: false } }
        }
      });
      setScatterChart(sc);
      return ()=>{ sc.destroy(); };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [simDetails]);

    React.useEffect(()=>{
      // histogram for selected route
      const route = solution.routes[routeIdx];
      if (!route) return;
      const vols = sampleVolumesForRoute(route, 600);
      const { labels, counts } = makeHistogram(vols, 22);
      const ctx = histRef.current.getContext('2d');
      if (histChart) histChart.destroy();
      const hc = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets: [{ label: `v${route.vehicle.id} load (L)`, data: counts, backgroundColor: '#10b981' }] },
        options: { responsive: true, scales: { x: { title: { display: true, text: 'Load (L)' } }, y: { title: { display: true, text: 'Frequency' }, beginAtZero: true } } }
      });
      setHistChart(hc);
      return ()=>{ hc.destroy(); };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [routeIdx, solution]);

    return (
      <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
        <div className="bg-white rounded-xl p-6 w-[960px] max-h-[85vh] overflow-auto" onClick={e=>e.stopPropagation()}>
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-xl font-bold">Monte Carlo Visualizations</h2>
            <button onClick={onClose} className="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
          </div>
          <div className="grid grid-cols-2 gap-4">
            <div className="bg-slate-50 p-3 rounded border">
              <div className="text-sm font-medium mb-2">Calibration: Predicted vs Realized</div>
              <canvas ref={scatterRef} height="200"></canvas>
              <div className="text-xs text-slate-500 mt-2">Each point is a route. Ideal behavior: lower predicted ratio → lower realized overflow.</div>
            </div>
            <div className="bg-slate-50 p-3 rounded border">
              <div className="flex items-center justify-between mb-2">
                <div className="text-sm font-medium">Load Distribution (per route)</div>
                <select value={routeIdx} onChange={e=>setRouteIdx(parseInt(e.target.value))} className="text-sm border rounded px-2 py-1">
                  {solution.routes.map((r, i)=> (
                    <option key={i} value={i}>{`v${r.vehicle.id}`}</option>
                  ))}
                </select>
              </div>
              <canvas ref={histRef} height="200"></canvas>
              <div className="text-xs text-slate-500 mt-2">Histogram of simulated total load; compare to vehicle capacity for overflow risk.</div>
            </div>
          </div>
        </div>
      </div>
    );
  }

  function CanvasView({ inst, solution, stepState }){
    const svgRef = useRef(null);

    const palette = [
      "#2563eb", "#059669", "#f59e0b", "#ef4444", "#7c3aed", "#0ea5e9", "#14b8a6",
      "#dc2626", "#f97316", "#e11d48"
    ];

    const routes = solution?.routes ?? stepState?.routes ?? [];

    // draw
    return (
      <svg ref={svgRef} viewBox={`0 0 ${CANVAS_W} ${CANVAS_H}`} className="w-full h-full">
        {/* bg grid */}
        <defs>
          <pattern id="grid" width="50" height="50" patternUnits="userSpaceOnUse">
            <path d="M 50 0 L 0 0 0 50" fill="none" stroke="#e2e8f0" strokeWidth="1"/>
          </pattern>
        </defs>
        <rect x="0" y="0" width={CANVAS_W} height={CANVAS_H} fill="url(#grid)" />

        {/* Depot */}
        <circle cx={inst.depot.x} cy={inst.depot.y} r={9} fill="#111827" />
        <text x={inst.depot.x+12} y={inst.depot.y+4} fontSize="12" fill="#111827">Depot</text>

        {/* Sites */}
        {inst.sites.map(s=>{
          const size = 4 + Math.min(10, s.mu/30);
          return (
            <g key={s.id}>
              <circle cx={s.x} cy={s.y} r={size} fill="#334155" opacity={0.9} />
              <text x={s.x+6} y={s.y-6} fontSize="10" fill="#334155">{s.id}</text>
            </g>
          );
        })}

        {/* Routes */}
        {routes.map((r,idx)=>{
          const color = palette[idx % palette.length];
          const pts = r.nodes.map(id => id===0? inst.depot : inst.sitesByIdx.get(id));
          const path = pts.map((p,i)=>`${i===0?"M":"L"}${p.x},${p.y}`).join(" ");
          return (
            <g key={idx}>
              <path d={path} fill="none" stroke={color} strokeWidth={3} opacity={0.85} />
              {/* capacity text */}
              <text x={10} y={20+16*idx} fontSize="12" fill={color}>
                {`v${r.vehicle.id}: μ=${r.muSum.toFixed(0)} L, σ≈${Math.sqrt(Math.max(0,r.varSum)).toFixed(0)} L`}
              </text>
            </g>
          );
        })}

        {/* Step highlight */}
        {stepState?.placed && (
          <g>
            {(() => {
              const { rIndex, pos } = stepState.placed;
              const r = stepState.routes[rIndex];
              const prev = r.nodes[pos-1];
              const sPrev = prev===0? inst.depot : inst.sitesByIdx.get(prev);
              const sid = stepState.current;
              const sNew = inst.sitesByIdx.get(sid);
              return (
                <g>
                  <circle cx={sNew.x} cy={sNew.y} r={10} fill="none" stroke="#10b981" strokeWidth={3} />
                  <line x1={sPrev.x} y1={sPrev.y} x2={sNew.x} y2={sNew.y} stroke="#10b981" strokeWidth={3} strokeDasharray="6 4"/>
                </g>
              );
            })()}
          </g>
        )}
      </svg>
    );
  }

  // mount
  ReactDOM.render(<App />, document.getElementById('root'));

  </script>
</body>
</html>
